<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Viewer - choose resolution & fps</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 16px; }
    select, input { margin-right: 8px; margin-bottom: 8px; }
    video { display:block; margin-top: 12px; width:80%; max-width:900px; border:1px solid #ddd; }
    #log { white-space: pre-wrap; background:#f7f7f7; padding:8px; border:1px solid #eee; max-height:200px; overflow:auto; font-size:12px; }
  </style>
</head>
<body>
  <h2>Viewer</h2>

  <div>
    <label for="streamerSelect">Streamer:</label>
    <select id="streamerSelect"></select>
    <button id="refresh">Refresh</button>
  </div>

  <div>
    <label for="resSelect">Resolution:</label>
    <select id="resSelect"></select>
    <label for="fpsSelect">FPS:</label>
    <select id="fpsSelect"></select>
  </div>

  <div><button id="watch">Watch</button></div>
  <video id="video" autoplay playsinline controls></video>

  <h4>Log</h4>
  <div id="log">init</div>

  <script>
    const ORIGIN = window.location.origin;
    const STREAMERS_API = ORIGIN + '/streamers';
    const SPECS_API = ORIGIN + '/streamer_specs';
    const WS_URL = (ORIGIN.startsWith('https') ? 'wss://' : 'ws://') + window.location.host + '/ws';

    const logEl = document.getElementById('log');
    function log(...a){ console.log(...a); logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }

    let specs = {};

    async function loadStreamersAndSpecs(){
      log('fetching streamers & specs from', ORIGIN);
      try {
        const r = await fetch(STREAMERS_API);
        const d = await r.json();
        const sel = document.getElementById('streamerSelect');
        sel.innerHTML = '';
        (d.streamers || []).forEach(s => { const o = document.createElement('option'); o.value=s; o.textContent=s; sel.appendChild(o); });
        log('streamers loaded', d.streamers);
      } catch(e){ log('fetch /streamers failed', e); }

      try {
        const r2 = await fetch(SPECS_API);
        const d2 = await r2.json();
        specs = d2.specs || {};
        log('specs loaded');
      } catch(e){ log('fetch /streamer_specs failed', e); }
      populateResFps();
    }

    // populate keeping sort (area desc), but default-select 1280x720 and fps=30 if exists
    function populateResFps(){
      const streamer = document.getElementById('streamerSelect').value;
      const list = (specs[streamer] || []).slice();  // copy list
      const res = document.getElementById('resSelect');
      const fps = document.getElementById('fpsSelect');
      res.innerHTML=''; fps.innerHTML='';

      if (list.length === 0){
        // fallback
        const o = document.createElement('option');
        o.value='0'; o.textContent='1280x720';
        res.appendChild(o);
        [30,15].forEach(f=>{
          const fo=document.createElement('option');
          fo.value=f; fo.textContent=f;
          fps.appendChild(fo);
        });
        return;
      }

      // sort resolutions by area desc (largest first) â€” keep this order
      list.sort((a,b) => (b.width*b.height) - (a.width*a.height));

      // populate resolution options in sorted order
      list.forEach((e,i)=>{
        const o=document.createElement('option');
        o.value=i;
        o.textContent = `${e.width}x${e.height}`;
        res.appendChild(o);
      });

      // find index of 1280x720 if exists
      let preferredResIndex = -1;
      for (let i = 0; i < list.length; i++){
        if (list[i].width === 1280 && list[i].height === 720){
          preferredResIndex = i;
          break;
        }
      }

      // default select: prefer 1280x720 if exists, otherwise first
      if (preferredResIndex !== -1) res.selectedIndex = preferredResIndex;
      else res.selectedIndex = 0;

      // populate fps for selected resolution; fps lists displayed in descending order
      function populateFpsForIndex(idx) {
        fps.innerHTML = '';
        const fpsList = (list[idx] && list[idx].fps_list) ? [...list[idx].fps_list] : [];
        fpsList.sort((a,b)=>b-a);
        fpsList.forEach(f => {
          const fo = document.createElement('option');
          fo.value = f; fo.textContent = f;
          fps.appendChild(fo);
        });

        // If selected resolution is 1280x720 and 30 exists, set fps selected to 30
        if (list[idx] && list[idx].width === 1280 && list[idx].height === 720) {
          const has30 = fpsList.indexOf(30) !== -1;
          if (has30) {
            for (let i = 0; i < fps.options.length; i++) {
              if (parseInt(fps.options[i].value, 10) === 30) { fps.selectedIndex = i; break; }
            }
            return;
          }
        }
        // else select first fps
        fps.selectedIndex = 0;
      }

      populateFpsForIndex(res.selectedIndex);

      // when user changes resolution, update fps (and default behavior applied for 1280x720)
      res.onchange = () => {
        populateFpsForIndex(parseInt(res.value, 10));
      };
    }

    document.getElementById('refresh').onclick = loadStreamersAndSpecs;

    document.getElementById('watch').onclick = async () => {
      const streamer = document.getElementById('streamerSelect').value;
      if (!streamer) return alert('choose streamer');
      const resIdx = parseInt(document.getElementById('resSelect').value || '0', 10);
      const fpsVal = parseInt(document.getElementById('fpsSelect').value || '30', 10);
      const chosen = (specs[streamer] || [])[resIdx] || {width:1280,height:720};
      const video_settings = { width: chosen.width, height: chosen.height, fps: fpsVal };

      const viewerId = 'viewer-' + Math.random().toString(36).slice(2,9);
      log('viewer id', viewerId, 'target', streamer, 'settings', video_settings);

      const ws = new WebSocket(WS_URL);
      let pc = null;

      ws.onopen = async () => {
        log('WS open, registering', viewerId);
        ws.send(JSON.stringify({ type:'register', role:'viewer', id: viewerId }));

        // LAN-only: no STUN/TURN, create RTCPeerConnection without iceServers
        pc = new RTCPeerConnection();
        pc.addTransceiver('video', { direction: 'recvonly' });

        pc.ontrack = (ev) => {
          document.getElementById('video').srcObject = ev.streams[0];
          log('remote track attached');
        };

        pc.onicecandidate = (e) => {
          if (!e.candidate) return;
          const cand = { candidate: e.candidate.candidate, sdpMid: e.candidate.sdpMid, sdpMLineIndex: e.candidate.sdpMLineIndex };
          ws.send(JSON.stringify({ type:'forward', target_role:'streamer', target_id: streamer, payload: { action:'candidate', candidate: cand } }));
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        ws.send(JSON.stringify({
          type:'forward',
          target_role:'streamer',
          target_id: streamer,
          payload: { action:'offer', sdp: pc.localDescription.sdp, video_settings: video_settings }
        }));
        log('offer sent');
      };

      ws.onmessage = async (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'forward' && msg.from_role === 'streamer') {
            const payload = msg.payload || {};
            if (payload.action === 'answer') {
              await pc.setRemoteDescription({ type:'answer', sdp: payload.sdp });
              log('answer set');
            } else if (payload.action === 'candidate') {
              try { await pc.addIceCandidate(payload.candidate); log('added remote candidate'); }
              catch(e){ log('addIceCandidate error', e); }
            }
          }
        } catch(e){ log('ws message parse error', e); }
      };

      ws.onclose = () => log('ws closed');
      ws.onerror = (err) => log('ws error', err);
    };

    // init on load
    loadStreamersAndSpecs();
  </script>
</body>
</html>
